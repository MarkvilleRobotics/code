#pragma config(Sensor, in1,    lfleft,         sensorLineFollower)
#pragma config(Sensor, in2,    lfcent,         sensorLineFollower)
#pragma config(Sensor, in3,    lfright,        sensorLineFollower)
#pragma config(Sensor, in4,    lightr,         sensorReflection)
#pragma config(Sensor, in5,    lightb,         sensorReflection)
#pragma config(Sensor, in6,    lighty,         sensorReflection)
#pragma config(Sensor, in7,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  front,          sensorTouch)
#pragma config(Sensor, dgtl2,  back,           sensorTouch)
#pragma config(Sensor, dgtl3,  left_s,         sensorTouch)
#pragma config(Sensor, dgtl4,  right_s,        sensorTouch)
#pragma config(Sensor, dgtl5,  snfr,           sensorSONAR_mm)
#pragma config(Sensor, dgtl7,  snbk,           sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  snlf,           sensorSONAR_inch)
#pragma config(Sensor, dgtl11, snrt,           sensorSONAR_mm)
#pragma config(Motor,  port1,           motorl,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           motortorq,     tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           motorclaw,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port10,          motorr,        tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(I2C_Usage, I2C1, i2cSensors)
//#pragma config(Sensor, I2C_1,     gyro,             sensorQuadEncoderOnI2CPort,        , AutoAssign)

//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

/* This version of auton-bot will be able to find and track a black tape on approach less than 60 degrees.
Work
In
Progress
*/
//					I2C Stuff starts here?
//####################################################
// Buffer for receive data
void i2ctest(){
char rxbuf[3];
// Set timeout at 100mS
int timeout = 10;

// Wait for 5 bytes of reply data
while( nI2CBytesReady < 3 && timeout != 0 ) {
  timeout--;
  wait1Msec(1);
  }

// Reply arrived ?
if(timeout > 0)
  readI2CReply( rxbuf, 3 );
}
//					I2C Stuff Ends here?
//####################################################
void grab(){
	motor[motortorq]=-25;
	wait(1);
}
void stoparm(){
	motor[motortorq]=0;
	wait(1);
}
void resetarm(){
	motor[motortorq]=25;
	wait(1);
}
void horizontal(){
	setServo(port9, 0);
	wait(1);
}
void release(){
	setServo(port9, 127);
	wait(1);
}
/*
void turnAngle(int gyro){
		if (gyro > ____ ){
		motor[] = ___;
		}
		else if (gyro < ____ ){
		motor[] = ___;
		}
		else{
		return 0;
		}
}
void moveUltra(){
		if (SensorValue[dgtl5] > ____ || SensorValue[dgtl7] > ___ ){
		motor[] = ___;
		}
		else if (SensorValue[dgtl5] < ____ || SensorValue[dgtl7] < ___){
		motor[] = ___;
		}
		else{
		return 0;
		}
}
*/
void wallslam(){
	for(;;){
		if (SensorValue[dgtl1] == 0 && SensorValue[dgtl2] == 0){
		motor[motorl] = 50;
		motor[motorr] = -50;
		delay (50);
		}
		else{
		motor[motorl] = 50;
		motor[motorr] = -50;
		delay (100);
		break;
		}
	}
}
void turnleft(){
	motor[motorl] = 30;
	motor[motorr] = 30;
	delay (50);
	//return 0;
}
void turnright(){
	motor[motorl] = -30;
	motor[motorr] = -30;
	delay (50);
	//return 0;
}
void trackline(int ls, int rs){
	//lm=v-k(l-r)
	//rm=v+k(l-r)
	motor[motorl] = 30+0.1*(rs-ls);
	motor[motorr] = -(30-0.1*(rs-ls));
	delay(5);
}

void findline(bool side, int ls, int rs){
	if (side) {
		if (rs>=2450){
			for(;;){
				trackline(SensorValue[in1]-200, SensorValue[in3]);
			}
		}
	}
	if (!side) {
		if (ls>=2450){
			for(;;){
				trackline(SensorValue[in1]-200, SensorValue[in3]);
			}
		}
	}
}


task main()
{
	for(;;){
	//setServo(port9, 127);
/*	motor[motorclaw] = -127;
	wait(0.5);
	setServo(port9, 127);
	wait(0.5);
}*/
	/*setServo(port9, 127);
	wait(0.5);
	horizontal();
	grab();
	stoparm();
	resetarm();
	release();
	*/
	i2ctest();}
	//wallslam();
	/*for(;;){
		motor[motorl] = 50;
		motor[motorr] = -50;
		if (SensorValue[in1] >= 2450 && SensorValue[in3] <= 2450){
			for(;;){
				findline(true, SensorValue[in1], SensorValue[in3]);
			}
		}
		else if (SensorValue[in3] >= 2450 && SensorValue[in1] <= 2450){
			for(;;){
				findline(false, SensorValue[in1], SensorValue[in3]);
			}
		}
		//trackline(SensorValue[in1],SensorValue[in3]);
	}*/
}
