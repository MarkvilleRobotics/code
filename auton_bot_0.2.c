#pragma config(Sensor, in1,    lfleft,         sensorLineFollower)
#pragma config(Sensor, in2,    lfcent,         sensorLineFollower)
#pragma config(Sensor, in3,    lfright,        sensorLineFollower)
#pragma config(Sensor, in4,    lightr,         sensorReflection)
#pragma config(Sensor, in5,    lightb,         sensorReflection)
#pragma config(Sensor, in6,    lighty,         sensorReflection)
#pragma config(Sensor, in7,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  front,          sensorTouch)
#pragma config(Sensor, dgtl2,  back,           sensorTouch)
#pragma config(Sensor, dgtl3,  left_s,           sensorTouch)
#pragma config(Sensor, dgtl4,  right_s,          sensorTouch)
#pragma config(Sensor, dgtl5,  snfr,           sensorSONAR_mm)
#pragma config(Sensor, dgtl7,  snbk,           sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  snlf,           sensorSONAR_inch)
#pragma config(Sensor, dgtl11, snrt,           sensorSONAR_mm)
#pragma config(Motor,  port1,           motorl,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port4,           motorelev,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           motortorq,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           motorclaw,     tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port10,          motorr,        tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*void grab(){
	motor[port6] = 60;
	delay (1000);
}*/
void turnleft(){
		motor[motorl] = 30;
		motor[motorr] = 30;
		delay (50);
		return 0;
	}
void turnright(){
		motor[motorl] = -30;
		motor[motorr] = -30;
		delay (50);
		return 0;
	}
void trackline(int ls, int rs){
	for(;;){
		motor[motorl] = 30+(ls-rs);
		motor[motorr] = -30-(ls+rs);
		delay(10);
	}
}
task main()
{
	/*for(;;){
 	motor[port5] = 100;
	}
	*/

	for(;;){
		motor[motorl] = 0;
		motor[motorr] = 0;
			while (SensorValue[in5] <= 850){
			motor[motorl] = 30;
			motor[motorr] = -30;
			delay(1);
			}
		if (SensorValue[in1] > 2000 && SensorValue[in2] > 2000){

		}
		else if(SensorValue[in3] > 2000){

		}
		//while (SensorValue[in5] > 980){
		//motor[motorl] = 127;
		//motor[motorr] = -127;
		//delay(1);
		//}
	}
}
